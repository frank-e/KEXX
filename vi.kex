'set novalue on'  /* force KEXX and its way of SIGNAL ON NOVALUE  */

/* Usage:         [MACRO] VI [file [options]]                     */
/* Example:       VI "C:=\my funny home page.html" (NOPROF        */
/* Purpose:       VI adds "long file name support" to Kedit 5 DOS */
/*                and KeditW 1.0 under NT.                        */
/* Operation:     VI evaluates =:=\=.= and DEFEXT like command X. */
/*    Step 2:     It then temporarily goes to the resulting drive */
/*                and directory.  If a directory is given it must */
/*                be a "short name" (8+3 components, no spaces)   */
/*                with at most 32 components (backslashes).       */
/*    Step 3:     In the target directory VI copies the file to a */
/*                new *.BAK file using CMD shell commands.  For a */
/*                not yet existing file an empty file is created. */
/*    Step 4:     VI then uses the Kedit DIR command to find the  */
/*                "short name" of the copied or created file, and */
/*                additionally matches the expected size (same as */
/*                *.BAK or 0 if new) or time (hh:mm if new).  The */
/*                extension is expected to be truncated to three  */
/*                characters by NT, e.g., *.HTM for *.HTML.       */
/*    Step 5:     Restore original =:= (drive and directory).     */
/*                Finally command X is used to edit the resulting */
/*                "short name" or the original name if not found. */
/* Caveats:       Macro VI does not (more try to) preserve an old */
/*                DIR.DIR file, because the code did not work for */
/*                DOS KEDIT 5 (spurious error 95).                */
/*                This macro does not remove the copied new *.BAK */
/*                or new empty file.  SET BACKUP TEMP erases any  */
/*                *.BAK automatically if edited files are saved.  */
/*              ! Do not use this macro if timestamps of *.BAK  ! */
/*              ! files are critical (makefiles, backup, etc.). ! */
/* Requires:      Kedit 5.0 or KeditW 1.0, NT CMD shell           */
/*                                        (Frank Ellermann, 2008) */

   HERE = fileid.1()                ;  'x dir.dir (new noprof)'
   if rc <> 0  then  exit rc        ;  else  do
      if HERE = fileid.1() then  do    /* find another base camp: */
         'x'                        ;  TEMP = fileid.1()
         'x "' || HERE || '"'       ;  HERE = TEMP
      end
      if HERE = fileid.1() then  do    /* 2nd choice 'MACROS.KML' */
         'macros'                   ;  TEMP = fileid.1()
         'x "' || HERE || '"'       ;  HERE = TEMP
      end
      if size.1() = 0   then  'qq'  ;  else  do
         parse source . . DIALOG.1  ;  DIALOG.1 = 'macro' DIALOG.1
         DIALOG.2 = 'Please confirm to QQuit existing DIR.DIR file'
         DIALOG.1 = delimit( DIALOG.1 )
         DIALOG.2 = delimit( DIALOG.2 )
         'dialog' DIALOG.2 'title' DIALOG.1 'OKCANCEL'
         if rc <> 0 | DIALOG.2 <> 'OK' then  exit rc
         'x dir.dir'                ;  'qquit'
      end
      'x "' || HERE || '"'             /* return to our base camp */
   end

   if left( strip( arg( 1 )), 1 ) <> '"'  then  do
      parse arg R '(' OPT
      if OPT <> ''   then  OPT = '(' || OPT
   end
   else  parse arg '"' R '"' OPT

   E = lastpos( '\', R )               /* --- evaluate FILEID --- */
   if E = 0 then  P = directory.1() ;  else  do
      P = left( R, E )              ;  R = substr( R, E + 1 )
   end
   if substr( P, 2, 1 ) = ':'          /* --- determine FMODE --- */
                  then  parse var P E 3 P
                  else  E = left( directory.1(), 2 )
   if E = '=:'    then  E = fmode.1()  /* '=:' means "this drive" */
   if P <> '\' then  do                /* --- determine FPATH --- */
      if right( P, 1 ) = '\'  then  P = left( P, length( P ) - 1 )
      if P = '='  then  P = fpath.1()  /* '=\' means "this path"  */
      if P = ''   then  P = substr( directory.1( D ), 3 )
   end
   P = E || P                          /* --- FNAME and FTYPE --- */
   N = lastpos( '.', R )            ;  T = substr( R, N + 1 )
   if N > 0       then  N = left( R, N - 1 ) ;  else  do
      N = R                         ;  T = ftype.1()
      if defext.1() = 'OFF' & N <> ''  then  T = ''
   end
   if T = '='     then  T = ftype.1()  /* =.= is "this name.type" */
   if abbrev( '=', N )  then  N = fname.1()
   'dmsg vi' P N || '.' || T           /* empty name => same name */

   E  = directory.1()               ;  R = CHDIR( P )
   if R <> 0   then  do
      'emsg bad path' P             ;  call CHDIR E   ;  exit R
   end

   if length( N ) <= 8 & length( T ) <= 3
      then  if datatype( N || T, 'A' ) then  R = N ;  else  R = ''
      else  R = ''
   if R = ''   then  R = SHORT( N, T ) /* find short name of file */
   if R = ''   then  R = EMPTY( N, T ) /* create a new empty file */
   if R <> ''  then  N = R             /* let Kedit handle errors */
   if P <> '\' then  P = P || '\'      /* special case root dir.  */
   T = '.' || left( T, min( 3, length( T )))
   'dmsg vi' P || N || T            ;  call CHDIR E
   'x  "' || P || N || T || '"' OPT ;  exit rc

CHDIR:   procedure                     /* expecting drive + path  */
   if version.1() = 'KEDIT' & right( version.3(), 1 ) = 1
      then  'chdir' arg( 1 )           /* Kedit 5.00 D1 or P1 bug */
      else  'chdir "' || arg( 1 ) || '"'
   if rc = 0   then  'chdrive' left( arg( 1 ), 1 )
   return rc

EMPTY:   procedure                     /* create a new empty file */
   parse arg NAME, TYPE                /* and return its 8+3 name */
   FULL = '"' || NAME || '.' || TYPE || '"'
   TYPE = '.' || left( TYPE, min( 3, length( TYPE )))
   do until NOW = time.2()             /* match timestamp + type: */
      NOW = time.2()
      'dosq cmd /c if not exist' FULL 'copy NUL' FULL
      if rc <> 0  then  exit rc        /* abnormal end, no damage */
   end

   'extract /CASE/DIRFORMAT/WRAP'   ;  T = DIRFORMAT.1 DIRFORMAT.2
   'dirformat' DIRFORMAT.1 3        ;  'nomsg dir *' || TYPE
   X = rc   ;  'dirformat' T        ;  if X <> 0   then  return ''
   if TYPE = '.'  then  TYPE = '    '  /* empty extension: no dot */

   if abbrev( NOW, 0 )  then  NOW = substr( NOW, 2 )
   WANTED = delimit( TYPE ) '& /' NOW '/'
   'case' CASE.1 'ignore'           ;  'wrap off'
   'nomsg :0 locate' WANTED         ;  X = rc

   do while rc = 0
      NAME = dirfileid.4()          ;  T = translate( curline.3())
      Y = translate( left( NAME, DIRFORMAT.1 ) || TYPE )
      parse var T . (Y) ' 0 ' . T . ;  if NOW = T  then  leave
      'nomsg locate' WANTED         ;  X = rc
   end
   if ring.0() > 1   then  'quit'
   'wrap' WRAP.1                    ;  'case' CASE.1 CASE.2
   if X <> 0   then  return ''      ;  else  return NAME

SHORT:   procedure                     /* copy old file to *.BAK  */
   parse arg NAME, TYPE                /* and return its 8+3 name */
   FULL = '"' || NAME || '.' || TYPE || '"'
   TYPE = '.' || left( TYPE, min( 3, length( TYPE )))
   X    = '"' || NAME || '.BAK"'
   do until NOW = time.2()             /* match timestamp + type: */
      NOW = time.2()
      'dosq cmd /c if exist' FULL 'copy /B NUL+' || FULL X
      if rc <> 0  then  exit rc        /* abnormal end, no damage */
   end

   'extract /CASE/DIRFORMAT/WRAP'   ;  T = DIRFORMAT.1 DIRFORMAT.2
   'dirformat' DIRFORMAT.1 3        ;  'nomsg dir *.BAK'
   X = rc   ;  'dirformat' T        ;  if X <> 0   then  return ''

   if abbrev( NOW, 0 )  then  NOW = substr( NOW, 2 )
   WANTED = '/.BAK/ & /' NOW '/'
   'case' CASE.1 'ignore'           ;  'wrap off'
   'nomsg :0 locate' WANTED         ;  X = rc
   do while rc = 0
      NAME = dirfileid.4()          ;  T = translate( curline.3())
      Y = translate( left( NAME, DIRFORMAT.1 ) || '.BAK' )
      parse var T . (Y) SIZE . T .  ;  if NOW = T  then  leave
      'nomsg locate' WANTED         ;  X = rc
   end
   if ring.0() > 1   then  'quit'   ;  T = DIRFORMAT.1 DIRFORMAT.2
   'wrap' WRAP.1                    ;  'case' CASE.1 CASE.2
   if X <> 0   then  return ''         /* file does not yet exist */

   'dirformat' DIRFORMAT.1 3        ;  'nomsg dir *' || TYPE
   X = rc   ;  'dirformat' T        ;  if X <> 0   then  return ''
   if TYPE = '.'  then  TYPE = '    '  /* empty extension: no dot */

   WANTED = delimit( TYPE ) '& /' SIZE '/'
   'case' CASE.1 'ignore'           ;  'wrap off'
   'nomsg :0 locate' WANTED         ;  X = rc
   do while rc = 0
      NAME = dirfileid.4()          ;  T = translate( curline.3())
      Y = translate( left( NAME, DIRFORMAT.1 ) || TYPE )
      parse var T . (Y) T .         ;  if SIZE = T then  leave
      'nomsg locate' WANTED         ;  X = rc
   end
   if ring.0() > 1   then  'quit'
   'wrap' WRAP.1                    ;  'case' CASE.1 CASE.2
   if X <> 0   then  return ''      ;  else  return NAME

