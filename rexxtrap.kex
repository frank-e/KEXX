'set novalue on'  /* force KEXX and its way of SIGNAL ON NOVALUE  */

/* Usage:         [MACRO] REXXTRAP [function(s)]                  */
/* Purpose:       Update all REXX *.CMD scripts with most recent  */
/*                version of common TRAP handler in REXXTRAP.CMD. */
/*                The TRAP: line (and any WHEN 1 selection) are   */
/*                matched exactly incl. blanks and REXX comments. */

/*                Optionally additional functions can be updated  */
/*                using their most recent REXXTRAP.CMD version in */
/*                scripts containg the common TRAP handler.  Only */
/*                function labels (starting in column 1) have to  */
/*                match exactly, the rest of the line is ignored. */
/*                Selective: F5 = skip, F6 = update, ESC = cancel */
/* Update 2008:   The 2003 version was designed for OS/2 Kedit 5  */
/*                and *.CMD scripts.  On NT with ooREXX a common  */
/*                TRAP handler in all *.REX scripts is pointless: */
/*                The ooREXX trap handler is normally good enough */
/*                and rather different from classic REXX with new */
/*                LOSTDIGITS, NOSTRING, etc. conditions.  For old */
/*                scripts using REXXTRAP snippets not limited to  */
/*                the obsolete trap handler this macro can still  */
/*                help with "bulk updates".                       */
/*                Isuues with long file names in the OS/2 version */
/*                are not applicable for DOS Kedit 5 or KeditW 1  */
/*                under NT:  These operating systems pretend that */
/*                everything is 8+3 for old DOS applications.     */
/* See also:      REXX.KEX                                        */
/*                <URL:http://purl.net/xyzzy/kex/rexxtrap.kex>    */
/*                <URL:http://purl.net/xyzzy/kex/rexx.kex>        */
/*                <URL:http://purl.net/xyzzy/rexxtrap.htm>        */
/*                <URL:http://purl.net/xyzzy/src/rexxtrap.cmd>    */
/* Requires:      REXXTRAP.CMD anywhere in the PATH               */
/*                Kedit 5.0               (Frank Ellermann, 2008) */

   APPS = PATH( 'REXXTRAP.CMD' )       /* PATH of REXXTRAP.CMD    */
   TRAP = APPS || 'REXXTRAP.CMD'       /* copy of REXX.KEX PATH() */
   APPS = left( APPS, length( APPS ) - 1 )
* ------------------------------------------------------------------
*  APPS = APPS || ';' || 'd:\apps\bin' /* example, add more dir.s */
* ---------------------------------------------------- OS/2 magic --
   NN.. = fileid.1()    ;  NN.0 = line.1()
   NN.1 = 0 ;  NN.2 = 0 ;  NN.3 = 0

   'extract /DIRFORMAT/DEFSORT/' ;  'defsort off'
   'nomsg dirform 12 4'                /* for OS/2, ignore error  */
   'dir "' || TRAP || '"'
   do while rc = 0 & APPS > ''         /* DIR APPS *.cmd scripts: */
      parse var APPS THIS ';' APPS
      'dirap "' || THIS || '\*.rex"'   /* use '\*.cmd"' for OS/2  */
*     'dirap "' || THIS || '\*.cmd"'   /* use '\*.rex"' otherwise */
   end
   THIS = rc
   'defsort' DEFSORT.1  ;  if THIS <> 0 then exit THIS
   'nomsg query attr'   ;  ATTR = lastmsg.1()

   'x "' || TRAP || '" (noprof)'       ;  TRAP = fileid.1()
   if rc == 0 then 'locate :1'         ;  if rc == 0 then 'set' ATTR
   if rc == 0 then 'tfind /TRAP: /'    ;  if rc <> 0 then exit rc
   THIS = delimit( curline.3())        /* temp. patch WHEN 1 THEN */
   'nomsg change /when 1 then/when 0 then/ *'
   'locate :1' THIS  ;  'put *'        ;  if rc <> 1 then exit rc

   'x dir.dir'       ;  'locate :1'    /* process DIR.DIR entries */
   do until focuseof()                 /* update TRAP: handlers   */
      'refresh'      ;  rc = ( TRAP = translate( dirfileid.1()))
      if rc == 0 then NN.1 = NN.1 + 1  /* count processed scripts */
      if rc == 0 then 'x "' || dirfileid.1() || '" (noprof)'
      if rc == 0 then do
         'set' ATTR  ;  APPS = EDIT( THIS )     ;  'quit'
         'x dir.dir' ;  if APPS <> 0 then 'del' ;  else 'next'
         NN.2 = NN.2 + ( APPS = 0 )    /* count modified  scripts */
      end                              /* DIR.DIR entries of all  */
      else  'del'                      /* skipped scripts deleted */
   end
   APPS = arg( 1 )                     /* after TRAP: process any */
   do while APPS > ''                  /* given REXXTRAP function */
      parse var APPS THIS APPS      ;  THIS = delimit( THIS || ':' )
      'x "' || TRAP || '"'          ;  'nomsg locate :0 tfind' THIS
      if rc <> 0 then iterate          /* ignore unknown function */
      'mark line reset'             ;  'arbchar on $ ?'
      'tfind /????: /'                 /* XXXX.YYYY: is NOT next  */
      'locate -1 mark line'         ;  'put block'
      if rc <> 0 then iterate          /* ignore PUT BLOCK error  */

      'x dir.dir'       ;  'locate :1' /* update THIS function in */
      do until focuseof()              /* all (remaining) scripts */
         'refresh'      ;  'x "' || dirfileid.1() || '" (noprof)'
         if rc = 0 then do             /* ignore rc <> 0 problem  */
            'set' ATTR  ;  'arrow off' /* count updated function: */
            if EDIT( THIS ) = 0 then NN.3 = NN.3 + 1
            'quit'                     /* set ATTR to get DIR.DIR */
         end                           /* colours for ALERT etc.  */
         'x dir.dir'    ;  'next'      /* despite option NOPROF   */
      end
   end                                 /* QQ to keep WHEN 1 THEN: */
   'x "' || TRAP || '"' ;  if TRAP <> NN.. then 'qquit'
   'x dir.dir'          ;  if ring.0() > 1 then 'qquit'
   'x "' || NN.. || '"' ;  'nomsg locate :' || NN.0
   say 'updated' NN.3 'functions in' NN.2 'of' NN.1 'scripts'
   exit rc

EDIT: procedure   /* -------------------------------------------- */
   ALERT.2 = 'OK'                      /* treat ALERT error as OK */
   'nomsg locate :0 tfind' arg( 1 ) ;  if rc <> 0 then return rc

   if abbrev( curline.3(), 'TRAP: ' ) then do
      'nomsg locate /when 1 then/'     /* get any SELECTed WHEN 1 */
      if rc = 0 then ALERT.1 = curline.3()   ;  else ALERT.1 = ''
      'locate :0 tfind' arg( 1 ) ;  'del *'  ;  'get'

      if ALERT.1 > '' then do          /* restore SELECTed WHEN 1 */
         ALERT.1 = delimit( translate( ALERT.1, 0, 1 ))
         ALERT.0 = delimit( 'cannot reset SELECTed TRAP' )
         'nomsg locate -' || ALERT.1
         if rc == 0 then 'change /when 0 then/when 1 then/ 1'
         if rc <> 0 then 'alert' ALERT.1 'title' ALERT.0 'OKcancel'
         if ALERT.2 <> 'OK' then exit 1
      end                              /* CANCEL = emergency exit */
   end
   else do                             /* not TRAP: => not at EOF */
      do until lastkey.1() = 'F6'
         say arg( 1 ) 'found (F5 = skip, F6 = update, ESC = cancel)'
         'readv key'                   /* ESCape = emergency exit */
         if lastkey.1() = 'ESC'  then  exit 1
         if lastkey.1() = 'F5'   then  return 1
      end
      'arbchar on $ ?'  ;  ALERT.0 = delimit( 'cannot replace' )
      'tfind /$:/ & ~/$ $:/ & ~/$.$:/' /* XXXX.YYYY: is NOT next  */
      if rc == 0  then  'locate -1 nomsg get'
      if rc == 0  then  'locate :0 tfind' arg( 1 )
      if rc == 0  then  'del' arg( 1 )
      if rc <> 0  then  'alert' arg( 1 ) 'title' ALERT.0 'OKcancel'
      if ALERT.2 <> 'OK' then exit 1   /* CANCEL = emergency exit */
   end
   'save'
   if rc <> 0 then do
      'alert /force Save ?/ title /Save error/ OKcancel'
      if ALERT.2 <> 'OK' then exit 1   /* CANCEL = emergency exit */
   end
   'ssave'  ;  return rc

PATH: procedure                        /* find arg(1) in the PATH */
   PATH = path.1()   ;  'set path on'  /* KEDIT searches the PATH */
   BACK = fileid.1() ;  FIND = strip( translate( arg( 1 )))
   'nomsg x "' || FIND || '" (noprof nodefext)'
   if rc = 0 then do                   /* found or new, test size */
      'set path' PATH                  /* reset user's KEDIT PATH */
      parse value fileid.1() with PATH (FIND) OKAY
      OKAY = ( OKAY == '' & size.1() > 0 )
      if ring.0() > 1 then 'nomsg quit'
      'nomsg x "' || BACK || '" (new nodefext)'
      if OKAY then return PATH
      'emsg' FIND 'not found in PATH or CWD'    ;  exit 1
   end
   'emsg cannot edit' FIND ;  'set path' PATH   ;  exit 1
